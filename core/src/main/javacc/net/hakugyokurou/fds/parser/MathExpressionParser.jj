options{	SUPPORT_CLASS_VISIBILITY_PUBLIC = false;	STATIC = false;}PARSER_BEGIN(MathExpressionParser)package net.hakugyokurou.fds.parser;import java.io.BufferedReader;import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.util.ArrayList;import net.hakugyokurou.fds.MathExpression;import net.hakugyokurou.fds.node.*;import net.hakugyokurou.fds.node.OperationNode.Operation;public class MathExpressionParser{	public static ArrayList<MathExpression> parse(Reader reader) throws InvalidExpressionException {		ArrayList<MathExpression> list = null;		try		{			MathExpressionParser parser = new MathExpressionParser(reader);			list = parser.parse();		}		catch(TokenMgrError e)        {        	throw new InvalidExpressionException("Failed to parse", e);        }		catch(Exception e)		{			throw new InvalidExpressionException("Failed to parse", e);		}		for(MathExpression expr : list)			expr.verify();		return list;	}	public static MathExpression parseLine(Reader reader) throws InvalidExpressionException {		MathExpression expr = null;		try		{			MathExpressionParser parser = new MathExpressionParser(reader);			expr = parser.parseLine();		}		catch(TokenMgrError e)        {        	throw new InvalidExpressionException("Failed to parse", e);        }		catch(Exception e)		{			throw new InvalidExpressionException("Failed to parse", e);		}		expr.verify();		return expr;	}	public static ArrayList<MathExpression> parseFile(File file) throws InvalidExpressionException, IOException {		if(!file.isFile() || !file.exists())			throw new IllegalArgumentException("File not exists!");		BufferedReader reader = null;		try {			reader = new BufferedReader(new FileReader(file));			return parse(reader);		} finally {			if(reader != null)				try {reader.close();} catch (IOException e) {}		}	}    private static OperationNode createOperationNode(int kind, IEvaluable left, IEvaluable right) {		OperationNode node = null;		switch (kind)		{			case ADD :				node = new OperationNode(Operation.ADD);				break;			case SUB :				node = new OperationNode(Operation.SUB);				break;			case MUL :				node = new OperationNode(Operation.MUL);				break;			case DIV :				node = new OperationNode(Operation.DIV);				break;		}		node.setLeft(left);		node.setRight(right);		return node;	}}PARSER_END(MathExpressionParser)SKIP :{	" "|	"\r"|	"\t"}TOKEN :{	< ADD : "+" >|	< SUB : "-" >|	< MUL : "*" >|	< DIV : "/" >|	< EOL : "\n" >}TOKEN :{	< INTEGER : (< DIGIT >)+ >|	< RATIONAL : (< DIGIT >)+ "." (< DIGIT >)* >|	< #DIGIT : [ "0"-"9" ] >}ArrayList < MathExpression > parse() :{	ArrayList < MathExpression > list = new ArrayList < MathExpression > ();	MathExpression expr = null;}{	(		expr = parseLine()		{			if (expr != null)			{				list.add(expr);				expr = null;			}		}	|	< EOL >	)*	< EOF >	{		return list;	}}MathExpression parseLine() :{	MathExpression expr = new MathExpression();	IEvaluable evaluable = null;}{	(		evaluable = sum()	)	(		LOOKAHEAD(2) < EOL >	)?	{		if(evaluable == null)			return null;		expr.setRoot(evaluable);		return expr;	}}private IEvaluable sum() :{	IEvaluable left = null, right = null;	Token token = null;	OperationNode currentNode = null;}{	left = mul()	( LOOKAHEAD(2)		(			token = < ADD >		|	token = < SUB >		)		right = mul()		{			OperationNode node = createOperationNode(token.kind, left, right);			if(currentNode != null)				node.setLeft(currentNode);			currentNode = node;		}	)*	{		return currentNode == null ? left : currentNode;	}}private IEvaluable mul() :{	IEvaluable left = null, right = null;	Token token = null;	OperationNode currentNode = null;}{	left = unary()	(		(			token = < MUL >		|	token = < DIV >		)		right = unary()		{			OperationNode node = createOperationNode(token.kind, left, right);			if(currentNode != null)				node.setLeft(currentNode);			currentNode = node;		}	)*	{		return currentNode == null ? left : currentNode;	}}private IEvaluable unary() :{	IEvaluable child = null;}{	< SUB >	(		child = element()	)	{		return new NegNode(child);	}|	child = element()	{		return child;	}}private IEvaluable element() :{	Token t1 = null, t2 = null;	IEvaluable child = null;}{	t1 = < INTEGER >	{		return new RationalNode((double) Long.parseLong(t1.image));	}|	t1 = < RATIONAL >	{		return new RationalNode(Double.parseDouble(t1.image));	}|	"[" t1 = < INTEGER > "/" t2 = < INTEGER > "]"	{		int n = Integer.parseInt(t1.image), d = Integer.parseInt(t2.image);		return new FractionNode(n, d);	}|	"(" child = sum() ")"	{		return new BracketNode(child);	}}